/** @file
 * composableNetlet.h
 *
 * @brief Generic classes for message passing within the same address space
 *
 * (c) 2008-2009 Institut fuer Telematik, Universitaet Karlsruhe (TH), Germany
 *
 *  Created on: Aug 14, 2009
 *      Author: denis
 */

#ifndef COMPOSABLENETLET_H_
#define COMPOSABLENETLET_H_

#include <netlet.h>
#include <messages.h>
#include <exceptions.h>

#include <string>
#include <map>

#include <boost/shared_ptr.hpp>

class CNena;
class IComposableNetlet;

/**
 * @brief 	Interface for a building block
 */
class IBuildingBlock : public IMessageProcessor {
protected:
	CNena *nena;
	IComposableNetlet * netlet;

public:    
	/**
	 * @brief 	Constructor
	 *
	 * @param nena	Pointer to Node Architecture class
	 * @param sched		Associated scheduler
	 * @param netlet	Associated Netlet
	 * @param id		id of the building block, has to be unique in netlet
	 */
	IBuildingBlock(CNena *nena, IMessageScheduler *sched, IComposableNetlet *netlet, const std::string id) :
		IMessageProcessor(sched), nena(nena), netlet(netlet)
	{
		className += "::IBuildingBlock";

		setId(id);
	};

	/**
	 * @brief	Destructor
	 */
	virtual ~IBuildingBlock() {};
};

/**
 * @brief	A base class for a Netlet composed of building blocks.
 *
 * 			Currently, only very simple compositions are supported. There are
 * 			only firmly wired chains of building blocks allowed, one for
 * 			outgoing data, one for incoming data. Furthermore, no signaling of
 * 			the used BB chain is supported, neither in-band, nor out-of-band.
 *
 * 			More sophisticated mechanisms supporting building block graphs
 * 			including branches and dynamic signaling may follow in the future.
 */
class IComposableNetlet : public INetlet
{
public:
	/**
	 * @brief	Thrown if a building block cannot be found.
	 */
	NENA_EXCEPTION(EUnknownBuildingBlock);

	/**
	 * @brief	Simple Building Block configuration. This class will be
	 * 			generated by the Netlet editor.
	 *
	 * 			More sophisticated mechanisms supporting building block graphs
	 * 			including branches and dynamic signaling may follow in the
	 * 			future.
	 */
	class Config
	{
	public:

		/**
		 * * @brief	Outgoing chain of building blocks from top to bottom.
		 *
		 * 			This is used by rewire() to rewire the building blocks.
		 */
		std::list<std::string> outgoingChain;

		/**
		 * @brief	Incoming chain of building blocks from bottom to top.
 		 *
 		 * 			This is used by rewire() to rewire the building blocks.
 		 */
		std::list<std::string> incomingChain;

		virtual ~Config() {};

	};

protected:
	/**
	 * @brief 	Map of all available blocks
	 */
	std::map<std::string, boost::shared_ptr<IBuildingBlock> > buildingBlocks;

	Config* config;

public:

	/**
	 * @brief 	Constructor.
	 */
	IComposableNetlet(CNena *nena, IMessageScheduler *sched) :
		INetlet(nena, sched)
	{
		className += "::IComposableNetlet";
		config = NULL;
	};

	/**
	 * @brief 	Destructor.
	 */
	virtual ~IComposableNetlet()
	{
	};

	/**
	 * @brief	Rewire the building blocks according to outgoingChain and
	 * 			incomingChain.
	 */
	virtual void rewire()
	{
		assert(config != NULL);
		// TODO what about ongoing transmissions?
		std::list<std::string>::const_iterator it, prev_it;

		// sanity checks first (may be optimized in the future)
		for (it = config->outgoingChain.begin(); it != config->outgoingChain.end(); it++) {
			std::map<std::string, boost::shared_ptr<IBuildingBlock> >::iterator bit = buildingBlocks.find(*it);
			if (bit == buildingBlocks.end()) throw EUnknownBuildingBlock(*it);
		}

		// sanity checks first (may be optimized in the future)
		for (it = config->incomingChain.begin(); it != config->incomingChain.end(); it++) {
			std::map<std::string, boost::shared_ptr<IBuildingBlock> >::iterator bit = buildingBlocks.find(*it);
			if (bit == buildingBlocks.end()) throw EUnknownBuildingBlock(*it);
		}

		// rewire outgoing chain
		for (prev_it = config->outgoingChain.begin(), it = prev_it, it++; it != config->outgoingChain.end(); prev_it++, it++) {
			buildingBlocks[*prev_it]->setNext(buildingBlocks[*it].get());
		}

		// rewire incoming chain
		for (prev_it = config->incomingChain.begin(), it = prev_it, it++; it != config->incomingChain.end(); prev_it++, it++) {
			buildingBlocks[*prev_it]->setPrev(buildingBlocks[*it].get());
		}

		// first and last BB
		if (config->outgoingChain.size() > 0)
			buildingBlocks[config->outgoingChain.back()]->setNext(this); // we need to add a header
		if (config->incomingChain.size() > 0)
			buildingBlocks[config->incomingChain.back()]->setPrev(this); // set some meta infos

		// just some debug info
		if (config->outgoingChain.size() == 0)
			DBG_WARNING(FMT("%1%::rewire(): Outgoing chain is empty!") % className);
		if (config->incomingChain.size() == 0)
			DBG_WARNING(FMT("%1%::rewire(): Incoming chain is empty!") % className);
	};

	virtual boost::shared_ptr<IBuildingBlock> getBuildingBlockByName (std::string name)
	{
		std::map<std::string, boost::shared_ptr<IBuildingBlock> >::iterator bbit = buildingBlocks.find(name);

		if (bbit != buildingBlocks.end())
			return buildingBlocks.find(name)->second;

		return boost::shared_ptr<IBuildingBlock>();
	}
};

#endif /* COMPOSABLENETLET_H_ */













