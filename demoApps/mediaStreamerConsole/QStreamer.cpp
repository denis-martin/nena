/******************************************************************************
 *   Copyright (C) 2009 Institut fuer Telematik, Universitaet Karlsruhe (TH)  *
 *                                                                            *
 *   This program is free software; you can redistribute it and/or modify     *
 *   it under the terms of the GNU General Public License as published by     *
 *   the Free Software Foundation; either version 2 of the License, or        *
 *   (at your option) any later version.                                      *
 *                                                                            *
 *   This program is distributed in the hope that it will be useful,          *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of           *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
 *   GNU General Public License for more details.                             *
 *                                                                            *
 *   You should have received a copy of the GNU General Public License        *
 *   along with this program; if not, write to the                            *
 *   Free Software Foundation, Inc.,                                          *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.                *
 ******************************************************************************/

/**
 * @file QStreamer.cpp
 * @author Helge Backhaus
 */

#include "QStreamer.h"

QStreamer::QStreamer() : QObject()
{
    pFormatCtx = NULL;
    pCodecCtx = NULL;
    pCodec = NULL;
    pFrame = NULL;
    pFrameRGB = NULL;
    buffer = NULL;
    img_convert_ctx = NULL;

    // Register all formats and codecs
    av_register_all();
}

QStreamer::~QStreamer()
{
    // Free the RGB image
    delete[] buffer;
    av_free(pFrameRGB);

    // Free the YUV frame
    av_free(pFrame);

    // Close the codec
    avcodec_close(pCodecCtx);

    // Close the video file
    av_close_input_file(pFormatCtx);
}

bool QStreamer::playFile(QString file)
{
	if (buffer) delete[] buffer;
	if (pFrameRGB) av_free(pFrameRGB);
	if (pFrame) av_free(pFrame);
	if (pCodecCtx) avcodec_close(pCodecCtx);
	if (pFormatCtx) av_close_input_file(pFormatCtx);

	buffer = NULL;
	pFrameRGB = NULL;
	pFrame = NULL;
	pCodecCtx = NULL;
	pFormatCtx = NULL;

    // Open video file
    if(av_open_input_file(&pFormatCtx, file.toAscii(), NULL, 0, NULL) != 0) {
        qDebug() << "STREAMER: Could not open" << file;
        return false; // Couldn't open file
    }
        
    // Retrieve stream information
    if(av_find_stream_info(pFormatCtx) < 0) {
        qDebug() << "STREAMER: No stream information found in" << file;
        return false; // Couldn't find stream information
    }
    
    // Find the first video stream
    videoStream = -1;
    for(unsigned int i = 0; i < pFormatCtx->nb_streams; ++i) {
        if(pFormatCtx->streams[i]->codec->codec_type == CODEC_TYPE_VIDEO) {
            videoStream = i;
            break;
        }
    }
    if(videoStream == -1) {
        qDebug() << "STREAMER: No video stream found in" << file;
        return false; // Didn't find a video stream
    }

    // Get a pointer to the codec context for the video stream
    pCodecCtx = pFormatCtx->streams[videoStream]->codec;

    // Find the decoder for the video stream
    pCodec = avcodec_find_decoder(pCodecCtx->codec_id);
    if(!pCodec) {
        qDebug() << "STREAMER: No codec found for" << file;
        return false; // Codec not found
    }

    // Open codec
    if(avcodec_open(pCodecCtx, pCodec) < 0) {
        qDebug() << "STREAMER: Could not open codec";
        return false; // Could not open codec
    }

    // Hack to correct wrong frame rates that seem to be generated by some codecs
    //if(pCodecCtx->time_base.num > 1000 && pCodecCtx->time_base.den == 1) {
    //    pCodecCtx->time_base.den = 1000;
    //}

    // Allocate video frame
    pFrame = avcodec_alloc_frame();

    // Allocate an AVFrame structure
    pFrameRGB = avcodec_alloc_frame();
    if(pFrameRGB == NULL) {
        qDebug() << "STREAMER: Frame allocation failed";
        return false;
    }

    // Determine required buffer size and allocate buffer
    numBytes = avpicture_get_size(PIX_FMT_RGB24, pCodecCtx->width, pCodecCtx->height);
    buffer = new unsigned char[numBytes];

    // Assign appropriate parts of buffer to image planes in pFrameRGB
    avpicture_fill((AVPicture*)pFrameRGB, (uint8_t*)buffer, PIX_FMT_RGB24, pCodecCtx->width, pCodecCtx->height);

    // Convert the image into YUV format that SDL uses
    img_convert_ctx = sws_getContext(pCodecCtx->width, pCodecCtx->height, pCodecCtx->pix_fmt, pCodecCtx->width, pCodecCtx->height, PIX_FMT_RGB24, SWS_BICUBIC, NULL, NULL, NULL);
    if(img_convert_ctx == NULL) {
        qDebug() << "STREAMER: Cannot initialize image conversion context";
        return false;
    }

    qDebug() << "STREAMER: Started playback of" << file;
    return true;
}

void QStreamer::getNextFrame()
{
    int frameFinished = 0;
    int seekBack = 0;
    while(seekBack >= 0 && frameFinished == 0) {
        seekBack = av_read_frame(pFormatCtx, &packet);
        if(seekBack < 0) {
            break;
        }
        // Is this a packet from the video stream?
        if(packet.stream_index == videoStream) {
            // Decode video frame
            avcodec_decode_video(pCodecCtx, pFrame, &frameFinished, packet.data, packet.size);

            // Did we get a video frame?
            if(frameFinished != 0) {
                sws_scale(img_convert_ctx, pFrame->data, pFrame->linesize, 0, pCodecCtx->height, pFrameRGB->data, pFrameRGB->linesize);
            }
        }
        // Free the packet that was allocated by av_read_frame
        av_free_packet(&packet);
    }
    if(seekBack < 0) {
        //av_seek_frame(pFormatCtx, videoStream, AV_TIME_BASE, AVSEEK_FLAG_BACKWARD);
        av_seek_frame(pFormatCtx, videoStream, 0, AVSEEK_FLAG_BACKWARD);
    }
}
